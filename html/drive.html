<!DOCTYPE html>
<html lang="en">
    <head>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
        <script src="https://unpkg.com/htmx.org@1.9.2" integrity="sha384-L6OqL9pRWyyFU3+/bjdSri+iIphTN/bvYyM37tICVyOJkWZLpP2vGn6VUEXgzg6h" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
        <title>Go Remote Control</title>
    </head>
<body>
     <!--Video-->
	<div id="videoDiv">
    </div>
    <div>
        <div>Controller Type</div>
        <div id="controllerType">Keyboard</div>
        <div>Current Command</div>
        <div id="currentCommand"></div>
    </div>
    <br /><br />Logs<br />
    <div id="div"></div>
</body>

<script type="text/javascript">
const socket = io();

const pc = new RTCPeerConnection({
    iceServers: [{
    urls: 'stun:stun.l.google.com:19302'
    }]
})

const log = msg => {
    document.getElementById('div').innerHTML += msg + '<br>'
}

pc.onicecandidateerror = e => {
    log("ICE Candidate Error: "+JSON.stringify(e))
    console.log("Connection State: "+JSON.stringify(e))
}

pc.onconnectionstatechange = e => {
    log("Connection State: "+pc.iceConnectionState)
    console.log("Connection State: "+pc.iceGatheringState)
}

pc.onicegatheringstatechange = e => {
    log("Ice Gathering State: "+pc.iceConnectionState)
    console.log("Ice Gathering State: "+pc.iceGatheringState)
}

pc.oniceconnectionstatechange = e => {
    log("Ice Connection State: "+pc.iceConnectionState)
    console.log("Ice Connection State: "+pc.iceConnectionState)
}

// pc.onnegotiationneeded = async () => {
//     try {
//         const offer = await pc.createOffer();
//         await pc.setLocalDescription(offer);

//         socket.emit('offer', btoa(JSON.stringify(pc.localDescription)));
//     } catch (error) {
//         console.error('Error creating offer:', error);
//     }
// };

pc.onicecandidate = event => {
    if (event.candidate === null) {
        console.log("Emmiting offer");
        socket.emit('offer', btoa(JSON.stringify(pc.localDescription)));
    }else{
        console.log("Found Candidate");
        socket.emit('candidate', btoa(JSON.stringify(event.candidate)));
    }
}

pc.ontrack = (event) => {
    console.log("Track Added");
    log("Track Added");
    const el = document.createElement(event.track.kind);
    el.srcObject = event.streams[0];
    el.autoplay = true;
    el.controls = true;
    document.getElementById('videoDiv').appendChild(el);
}

//Offer to receive 1 audio, and 1 video track
pc.addTransceiver('video', {
    direction: 'recvonly'
})
// pc.addTransceiver('audio', {
//     direction: 'recvonly'
// })

pc.createOffer().then(d => pc.setLocalDescription(d)).catch(log)

socket.on('answer', (answer) => {
    let decodedAnswer = JSON.parse(atob(answer));
    log("Setting remote Description");
    console.log("Setting Remote Description");
    console.log(JSON.stringify(decodedAnswer));

    pc.setRemoteDescription(decodedAnswer)
        .then(() => {
            console.log("Set Remote Description");
            console.log(JSON.stringify(pc.remoteDescription));
            log("Set remote Description");
        })
        .catch((error) => {
            console.error("Error setting remote description:", error);
            alert("Error setting remote description: " + error.message);
        });
});

socket.on('candidate', async(candidate) => {
    try {
        setTimeout(async() => {
            const decodedCandidate = JSON.parse(atob(candidate));
            console.log(JSON.stringify(decodedCandidate))
            await pc.addIceCandidate(decodedCandidate);
            log('Added ICE candidate');
            console.log("Added ICE candidate");
        }, 1000);
    } catch (e) {
        alert(e);
    }
});

// global gamepad object
let gamepadIndex;
window.addEventListener('gamepadconnected', (event) => {
    gamepadIndex = event.gamepad.index;
});

function mapToRange(value, min, max, minReturn, maxReturn) {
  return Math.floor((maxReturn-minReturn) * (value-min)/(max-min) + minReturn)
}

setInterval(() => {
    if(gamepadIndex !== undefined) {
        // a gamepad is connected and has an index
        const myGamepad = navigator.getGamepads()[gamepadIndex];

        let command = [127,127,127,127]

        document.getElementById('controllerType').innerHTML = myGamepad.id;
        if(myGamepad.id.toLowerCase().includes("xbox")){
            //esc
            if(myGamepad.buttons[6].value > .1 &&  myGamepad.buttons[6].value >= myGamepad.buttons[7].value){
            command[0] = 127 - mapToRange(myGamepad.buttons[6].value, .1, 1, 0, 127)
            }else if(myGamepad.buttons[7].value > .1){
                //gas
                command[0] = mapToRange(myGamepad.buttons[7].value, .1, 1, 127, 255)
            }else{
                //neutral
                command[0] = 127
            }
            //servo
            if(myGamepad.axes[0] > .1){
                command[1] = mapToRange(myGamepad.axes[0], .1, 1, 127, 255)
            }else if(myGamepad.axes[0] < -.1){
                command[1] = mapToRange(myGamepad.axes[0], -1, -.1, 0, 127)
            }else{
                command[1] = 127
            }

            //pan
            if(myGamepad.axes[2] > .1){
                command[2] = mapToRange(myGamepad.axes[2], .1, 1, 127, 255)
            }else if(myGamepad.axes[2] < -.1){
                command[2] = mapToRange(myGamepad.axes[2], -1, -.1, 0, 127)
            }else{
                command[2] = 127
            }

            //tilt
            if(myGamepad.axes[3] > .1){
                command[3] = mapToRange(myGamepad.axes[3], .1, 1, 127, 255)
            }else if(myGamepad.axes[3] < -.1){
                command[3] = mapToRange(myGamepad.axes[3], -1, -.1, 0, 127)
            }else{
                command[3] = 127
            }
            socket.emit('command', command);
            document.getElementById('currentCommand').innerHTML = 'Esc: '+command[0] + ' Servo: '+command[1] + ' Pan: ' + command[2] + ' Tilt: ' + command[3];
        }else{
            document.getElementById('controllerType').innerHTML = "Unsupported - " + myGamepad.id;
        }
    }
}, 10); // print buttons that are pressed 10 times per second

</script>
</html>